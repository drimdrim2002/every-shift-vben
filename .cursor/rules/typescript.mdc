---
description: TypeScript coding standards and best practices for modern web development
globs: **/*.ts, **/*.tsx, **/*.d.ts
---

# TypeScript Best Practices

## Type System
- Prefer interfaces over types for object definitions
- Use type for unions, intersections, and mapped types
- Avoid using `any`, prefer `unknown` for unknown types
- Use strict TypeScript configuration
- Leverage TypeScript's built-in utility types
- Use generics for reusable type patterns

## Naming Conventions
- Use PascalCase for type names and interfaces
- Use camelCase for variables and functions
- Use UPPER_CASE for constants
- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)
- Prefix interfaces for React props with 'Props' (e.g., ButtonProps)

## Code Organization
- Keep type definitions close to where they're used
- Export types and interfaces from dedicated type files when shared
- Use barrel exports (index.ts) for organizing exports
- Place shared types in a `types` directory
- Co-locate component props with their components

## Functions
- Use explicit return types for public functions
- Use arrow functions for callbacks and methods
- Implement proper error handling with custom error types
- Use function overloads for complex type scenarios
- Prefer async/await over Promises

## Best Practices
- Enable strict mode in tsconfig.json
- Use readonly for immutable properties
- Leverage discriminated unions for type safety
- Use type guards for runtime type checking
- Implement proper null checking
- Avoid type assertions unless necessary

## Error Handling
- Create custom error types for domain-specific errors
- Use Result types for operations that can fail
- Implement proper error boundaries
- Use try-catch blocks with typed catch clauses
- Handle Promise rejections properly

## Patterns
- Use the Builder pattern for complex object creation
- Implement the Repository pattern for data access
- Use the Factory pattern for object creation
- Leverage dependency injection
- Use the Module pattern for encapsulation

## ESLint Compliance Rules

### Console Usage
- NEVER use `console.debug()` or `console.log()` - ESLint will error
- ONLY use `console.warn()` or `console.error()` for logging
- For debugging, prefer `console.warn()` over `console.debug()`

### Global Object Access
- NEVER use `global`, `self`, or `window` directly when possible
- ALWAYS use `globalThis` instead of `global` or `self`
- For `process` access: use `globalThis.process` instead of `process`
- For `window` checks: use `typeof window !== 'undefined'` (allowed)

### Type Checking and Comparisons
- ALWAYS use strict equality (`===` and `!==`) instead of `==` or `!=`
- For `typeof` checks: use `!== 'undefined'` or `=== 'undefined'`
- For object existence: use `!== undefined` instead of `!= undefined`
- Example: `import.meta !== undefined` not `typeof import.meta !== 'undefined'`

### Environment Variable Access
- Browser (Vite): use `import.meta.env[key]` 
- Node.js: use `globalThis.process.env[key]` or `process.env[key]`
- Check existence: `import.meta !== undefined && import.meta.env`
- Cross-environment: create helper functions that check both

### Common ESLint Error Patterns to Avoid
```typescript
// ❌ BAD - ESLint will error
console.debug('message');
console.log('message');
if (typeof import.meta !== 'undefined') // prefer direct check
if (process.env.VAR == 'value') // use strict equality
global.something // use globalThis instead

// ✅ GOOD - ESLint compliant
console.warn('message');
console.error('message');
if (import.meta !== undefined)
if (process.env.VAR === 'value')
globalThis.process.env.VAR
```

### Cross-Environment Patterns
```typescript
// ✅ GOOD - Browser + Node.js compatible
function getEnvVar(key: string): string | undefined {
  // Browser environment (Vite)
  if (typeof window !== 'undefined') {
    if (import.meta !== undefined && import.meta.env) {
      return import.meta.env[key];
    }
  }
  
  // Node.js environment
  if (globalThis.process !== undefined && globalThis.process.env) {
    return globalThis.process.env[key];
  }
  
  return undefined;
}
```
